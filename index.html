<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Simple Pac-Man Game</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background-color: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    #game-container {
      position: relative;
      /* Increased to make the maze larger */
      width: 600px;
      height: 660px;
      border: 4px solid #00F;
      background-color: #000;
    }

    #score {
      color: white;
      font-size: 24px;
      margin-bottom: 10px;
    }

    .pacman {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      z-index: 2;
      background-color: transparent;
      background-image: url('icon/wpface.png');
      background-size: cover;
    }

    .ghost {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: transparent;
      background-image: none; /* This will be set by JavaScript */
      background-size: cover;
      z-index: 1;
    }

    .pellet {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: transparent;
      background-image: url('icon/book.png');
      background-size: cover;
    }

    .wall {
      position: absolute;
      background-color: #00F;
    }

    #game-over, #game-start {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 36px;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      display: none;
    }

    button {
      background-color: #FFFF00;
      border: none;
      padding: 10px 20px;
      font-size: 18px;
      margin-top: 20px;
      cursor: pointer;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="game-container">
    <div id="game-start">
      <h2>PAC-MAN</h2>
      <p>Use arrow keys to move</p>
      <button id="start-button">Start Game</button>
    </div>
    <div id="game-over">
      <h2>GAME OVER</h2>
      <p id="final-score">Your score: 0</p>
      <button id="restart-button">Play Again</button>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Game variables
      const gameContainer = document.getElementById('game-container');
      const scoreDisplay = document.getElementById('score');
      const gameOverScreen = document.getElementById('game-over');
      const gameStartScreen = document.getElementById('game-start');
      const finalScoreDisplay = document.getElementById('final-score');
      const startButton = document.getElementById('start-button');
      const restartButton = document.getElementById('restart-button');

      let score = 0;
      let pacman;
      let ghosts = [];
      let pellets = [];
      let walls = [];
      let gameRunning = false;
      let gameInterval;

      // Updated container dimensions to make a larger maze
      const containerWidth = 600;
      const containerHeight = 660;
      const pacmanSize = 20;
      const pelletSize = 8;
      const ghostSize = 20;
      const wallThickness = 8;

      // Direction variables
      let direction = 'right';
      let nextDirection = 'right';
      const speed = 2;
      const ghostSpeed = 2;

      // Ghost colors (unused in code but kept for reference)
      const ghostColors = ['#FF0000', '#00FFFF', '#FFB8FF', '#FFB852'];

      // Start and restart game
      startButton.addEventListener('click', startGame);
      restartButton.addEventListener('click', startGame);

      // Show start screen initially
      gameStartScreen.style.display = 'block';

      function startGame() {
        // Reset game state
        gameContainer.innerHTML = '';
        gameContainer.appendChild(gameOverScreen);
        gameContainer.appendChild(gameStartScreen);

        gameOverScreen.style.display = 'none';
        gameStartScreen.style.display = 'none';

        score = 0;
        scoreDisplay.textContent = `Score: ${score}`;
        ghosts = [];
        pellets = [];
        walls = [];
        gameRunning = true;

        // Create maze walls
        createWalls();

        // Create pellets
        createPellets();

        // Create pacman in a position where it can move freely
        pacman = document.createElement('div');
        pacman.className = 'pacman';
        pacman.style.left = '300px';
        pacman.style.top = '520px';
        gameContainer.appendChild(pacman);

        // Create ghosts in positions where they can move freely
        createGhosts();

        // Start game loop
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(updateGame, 20);

        // Listen for keyboard input
        document.addEventListener('keydown', handleKeyPress);
      }

      function createWalls() {
        // Outer border walls
        // Top
        createWall(0, 0, containerWidth, wallThickness);
        // Bottom
        createWall(0, containerHeight - wallThickness, containerWidth, wallThickness);
        // Left
        createWall(0, 0, wallThickness, containerHeight);
        // Right
        createWall(containerWidth - wallThickness, 0, wallThickness, containerHeight);

        // Create tunnels on left and right for wrapping
        createWall(0, 300, 100, wallThickness); // top of left tunnel
        createWall(0, 340, 100, wallThickness); // bottom of left tunnel
        createWall(containerWidth - 100, 300, 100, wallThickness); // top of right tunnel
        createWall(containerWidth - 100, 340, 100, wallThickness); // bottom of right tunnel

        // Top section
        // Top left corner block
        createWall(40, 40, 80, wallThickness); // horizontal top
        createWall(40, 40, wallThickness, 80); // vertical left
        
        // Top right corner block
        createWall(containerWidth - 120, 40, 80, wallThickness); // horizontal top
        createWall(containerWidth - 40, 40, wallThickness, 80); // vertical right
        
        // Top T shapes
        createWall(160, 40, 80, wallThickness); // horizontal top left
        createWall(200, 40, wallThickness, 80); // vertical top left
        
        createWall(containerWidth - 240, 40, 80, wallThickness); // horizontal top right
        createWall(containerWidth - 200, 40, wallThickness, 80); // vertical top right
        
        // Middle top section
        createWall(280, 40, 40, wallThickness); // horizontal top middle
        createWall(300, 40, wallThickness, 80); // vertical top middle

        // Upper middle section - left side
        createWall(80, 120, 80, wallThickness); // horizontal
        createWall(80, 120, wallThickness, 80); // vertical
        createWall(40, 160, 80, wallThickness); // lower horizontal
        
        // Upper middle section - right side
        createWall(containerWidth - 160, 120, 80, wallThickness); // horizontal
        createWall(containerWidth - 80, 120, wallThickness, 80); // vertical
        createWall(containerWidth - 120, 160, 80, wallThickness); // lower horizontal
        
        // T shapes in upper middle
        createWall(200, 120, 60, wallThickness); // horizontal left
        createWall(200, 120, wallThickness, 120); // vertical left
        
        createWall(containerWidth - 260, 120, 60, wallThickness); // horizontal right
        createWall(containerWidth - 200, 120, wallThickness, 120); // vertical right
        
        // Middle section
        createWall(280, 160, 40, wallThickness); // upper horizontal
        createWall(300, 160, wallThickness, 40); // upper vertical
        
        // Ghost area (middle) - redesigned without central house
        createWall(240, 200, 120, wallThickness); // upper horizontal
        createWall(240, 200, wallThickness, 40); // left vertical
        createWall(360, 200, wallThickness, 40); // right vertical
        
        // Lower middle section
        createWall(120, 240, 80, wallThickness); // horizontal left
        createWall(120, 240, wallThickness, 80); // vertical left
        
        createWall(containerWidth - 200, 240, 80, wallThickness); // horizontal right
        createWall(containerWidth - 120, 240, wallThickness, 80); // vertical right
        
        // Bottom T shapes
        createWall(40, 320, 80, wallThickness); // horizontal left
        createWall(80, 320, wallThickness, 80); // vertical left
        
        createWall(containerWidth - 120, 320, 80, wallThickness); // horizontal right
        createWall(containerWidth - 80, 320, wallThickness, 80); // vertical right
        
        // Lower section
        createWall(160, 320, 80, wallThickness); // horizontal left
        createWall(200, 320, wallThickness, 80); // vertical left
        
        createWall(containerWidth - 240, 320, 80, wallThickness); // horizontal right
        createWall(containerWidth - 200, 320, wallThickness, 80); // vertical right
        
        // Bottom section
        createWall(280, 320, 40, wallThickness); // horizontal middle
        createWall(300, 320, wallThickness, 80); // vertical middle
        
        // Bottom left L shape
        createWall(40, 400, 120, wallThickness); // horizontal
        createWall(40, 400, wallThickness, 80); // vertical
        createWall(80, 440, 40, wallThickness); // small horizontal
        
        // Bottom right L shape
        createWall(containerWidth - 160, 400, 120, wallThickness); // horizontal
        createWall(containerWidth - 40, 400, wallThickness, 80); // vertical
        createWall(containerWidth - 120, 440, 40, wallThickness); // small horizontal
        
        // Bottom T shapes
        createWall(160, 400, 40, wallThickness); // horizontal left
        createWall(200, 400, wallThickness, 80); // vertical left
        
        createWall(containerWidth - 200, 400, 40, wallThickness); // horizontal right
        createWall(containerWidth - 200, 400, wallThickness, 80); // vertical right
        
        // Bottom central section
        createWall(240, 400, 120, wallThickness); // horizontal 
        createWall(240, 440, 120, wallThickness); // lower horizontal
        
        // Very bottom section
        createWall(40, 480, 80, wallThickness); // left horizontal
        createWall(80, 480, wallThickness, 80); // left vertical
        
        createWall(containerWidth - 120, 480, 80, wallThickness); // right horizontal
        createWall(containerWidth - 80, 480, wallThickness, 80); // right vertical
        
        createWall(160, 480, 80, wallThickness); // middle left horizontal
        createWall(200, 480, wallThickness, 80); // middle left vertical
        
        createWall(containerWidth - 240, 480, 80, wallThickness); // middle right horizontal
        createWall(containerWidth - 200, 480, wallThickness, 80); // middle right vertical
        
        createWall(280, 480, 40, wallThickness); // center horizontal
        createWall(300, 480, wallThickness, 80); // center vertical
        
        // Bottom row
        createWall(40, 560, 520, wallThickness); // bottom horizontal
      }

      function createWall(x, y, width, height) {
        const wall = document.createElement('div');
        wall.className = 'wall';
        wall.style.left = `${x}px`;
        wall.style.top = `${y}px`;
        wall.style.width = `${width}px`;
        wall.style.height = `${height}px`;
        gameContainer.appendChild(wall);
        walls.push({ x, y, width, height });
      }

      function createPellets() {
        // Create a grid of pellets, avoiding walls
        const gridSize = 20;

        for (let x = 20; x < containerWidth; x += gridSize) {
          for (let y = 20; y < containerHeight; y += gridSize) {
            // Skip areas where walls are
            if (!isCollidingWithWalls(x, y, pelletSize, pelletSize)) {
              createPellet(x, y);
            }
          }
        }
      }

      function createPellet(x, y) {
        const pellet = document.createElement('div');
        pellet.className = 'pellet';
        pellet.style.left = `${x}px`;
        pellet.style.top = `${y}px`;
        gameContainer.appendChild(pellet);
        pellets.push({
          x,
          y,
          element: pellet,
          eaten: false
        });
      }

      function createGhosts() {
        // Place ghosts in different areas of the maze
        const positions = [
          { x: 280, y: 240 },  // center
          { x: 320, y: 240 },  // center
          { x: 240, y: 240 },  // center
          { x: 300, y: 280 }   // slightly below center
        ];

        for (let i = 0; i < 4; i++) {
          const ghost = document.createElement('div');
          ghost.className = 'ghost';
          ghost.style.left = `${positions[i].x}px`;
          ghost.style.top = `${positions[i].y}px`;
          ghost.style.backgroundColor = 'transparent';
          ghost.style.backgroundImage = `url('icon/ghost${i+1}.png')`;
          gameContainer.appendChild(ghost);

          ghosts.push({
            x: positions[i].x,
            y: positions[i].y,
            element: ghost,
            direction: getRandomDirection()
          });
        }
      }

      function getRandomDirection() {
        const directions = ['up', 'down', 'left', 'right'];
        return directions[Math.floor(Math.random() * directions.length)];
      }

      function updateGame() {
        if (!gameRunning) return;

        // Update pacman position
        movePacman();

        // Check for pellet collisions
        checkPelletCollisions();

        // Move ghosts
        moveGhosts();

        // Check for ghost collisions
        checkGhostCollisions();

        // Check if all pellets are eaten
        if (pellets.every(pellet => pellet.eaten)) {
          // You win!
          gameOver(true);
        }
      }

      function movePacman() {
        let newX = parseInt(pacman.style.left);
        let newY = parseInt(pacman.style.top);

        // Attempt to change direction if there's a queued direction
        if (nextDirection !== direction) {
          let testX = newX;
          let testY = newY;

          switch (nextDirection) {
            case 'up':
              testY -= speed;
              break;
            case 'down':
              testY += speed;
              break;
            case 'left':
              testX -= speed;
              break;
            case 'right':
              testX += speed;
              break;
          }

          // Check if new direction collides with walls
          if (!isCollidingWithWalls(testX, testY, pacmanSize, pacmanSize)) {
            direction = nextDirection;
          }
        }

        // Move pacman in the current direction
        switch (direction) {
          case 'up':
            newY -= speed;
            break;
          case 'down':
            newY += speed;
            break;
          case 'left':
            newX -= speed;
            // Handle tunnel wrap on left side
            if (newX < -pacmanSize && newY > 300 && newY < 340) {
              newX = containerWidth;
            }
            break;
          case 'right':
            newX += speed;
            // Handle tunnel wrap on right side
            if (newX > containerWidth && newY > 300 && newY < 340) {
              newX = -pacmanSize;
            }
            break;
        }

        // Check wall collisions
        if (!isCollidingWithWalls(newX, newY, pacmanSize, pacmanSize)) {
          pacman.style.left = `${newX}px`;
          pacman.style.top = `${newY}px`;
        }
      }

      function isCollidingWithWalls(x, y, width, height) {
        for (const wall of walls) {
          if (
            x < wall.x + wall.width &&
            x + width > wall.x &&
            y < wall.y + wall.height &&
            y + height > wall.y
          ) {
            return true;
          }
        }
        return false;
      }

      function checkPelletCollisions() {
        const pacmanX = parseInt(pacman.style.left) + pacmanSize / 2;
        const pacmanY = parseInt(pacman.style.top) + pacmanSize / 2;

        for (const pellet of pellets) {
          if (!pellet.eaten) {
            const pelletX = pellet.x + pelletSize / 2;
            const pelletY = pellet.y + pelletSize / 2;

            const distance = Math.sqrt(
              Math.pow(pacmanX - pelletX, 2) + Math.pow(pacmanY - pelletY, 2)
            );

            if (distance < (pacmanSize / 2) + (pelletSize / 2)) {
              // Pellet eaten
              pellet.eaten = true;
              pellet.element.style.display = 'none';
              score += 10;
              scoreDisplay.textContent = `Score: ${score}`;
            }
          }
        }
      }

      function moveGhosts() {
        for (const ghost of ghosts) {
          let newX = ghost.x;
          let newY = ghost.y;

          // Occasionally change direction randomly
          if (Math.random() < 0.02) {
            ghost.direction = getRandomDirection();
          }

          // Also try to change direction at intersections
          if (Math.random() < 0.1) {
            // Check for possible directions at current position
            const possibleDirections = [];
            
            // Check each direction
            if (!isCollidingWithWalls(ghost.x, ghost.y - ghostSpeed, ghostSize, ghostSize)) {
              possibleDirections.push('up');
            }
            if (!isCollidingWithWalls(ghost.x, ghost.y + ghostSpeed, ghostSize, ghostSize)) {
              possibleDirections.push('down');
            }
            if (!isCollidingWithWalls(ghost.x - ghostSpeed, ghost.y, ghostSize, ghostSize)) {
              possibleDirections.push('left');
            }
            if (!isCollidingWithWalls(ghost.x + ghostSpeed, ghost.y, ghostSize, ghostSize)) {
              possibleDirections.push('right');
            }
            
            // If there are multiple possible directions, maybe choose a new one
            if (possibleDirections.length > 1) {
              ghost.direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
            }
          }

          // Move ghost in current direction
          switch (ghost.direction) {
            case 'up':
              newY -= ghostSpeed;
              break;
            case 'down':
              newY += ghostSpeed;
              break;
            case 'left':
              newX -= ghostSpeed;
              // Handle tunnel wrap on left side
              if (newX < -ghostSize && newY > 300 && newY < 340) {
                newX = containerWidth;
              }
              break;
            case 'right':
              newX += ghostSpeed;
              // Handle tunnel wrap on right side
              if (newX > containerWidth && newY > 300 && newY < 340) {
                newX = -ghostSize;
              }
              break;
          }

          // Check wall collisions
          if (!isCollidingWithWalls(newX, newY, ghostSize, ghostSize)) {
            ghost.x = newX;
            ghost.y = newY;
            ghost.element.style.left = `${newX}px`;
            ghost.element.style.top = `${newY}px`;
          } else {
            // Change direction if hit a wall
            ghost.direction = getRandomDirection();
          }
        }
      }

      function checkGhostCollisions() {
        const pacmanX = parseInt(pacman.style.left) + pacmanSize / 2;
        const pacmanY = parseInt(pacman.style.top) + pacmanSize / 2;

        for (const ghost of ghosts) {
          const ghostX = ghost.x + ghostSize / 2;
          const ghostY = ghost.y + ghostSize / 2;

          const distance = Math.sqrt(
            Math.pow(pacmanX - ghostX, 2) + Math.pow(pacmanY - ghostY, 2)
          );

          if (distance < (pacmanSize / 2) + (ghostSize / 2)) {
            // Ghost collision
            gameOver(false);
            return;
          }
        }
      }

      function gameOver(win) {
        gameRunning = false;
        clearInterval(gameInterval);

        finalScoreDisplay.textContent = `Your score: ${score}`;
        gameOverScreen.style.display = 'block';

        if (win) {
          document.querySelector('#game-over h2').textContent = 'YOU WIN!';
        } else {
          document.querySelector('#game-over h2').textContent = 'GAME OVER';
        }
      }

      function handleKeyPress(e) {
        switch (e.key) {
          case 'ArrowUp':
            nextDirection = 'up';
            break;
          case 'ArrowDown':
            nextDirection = 'down';
            break;
          case 'ArrowLeft':
            nextDirection = 'left';
            break;
          case 'ArrowRight':
            nextDirection = 'right';
            break;
        }
      }
    });
  </script>
</body>
</html>
