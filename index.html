<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Classic Pac-Man Game</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background-color: #000;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #game-container {
      position: relative;
      width: 560px;
      height: 620px;
      border: 4px solid #00F;
      background-color: #000;
    }
    #score {
      color: white;
      font-size: 24px;
      margin-bottom: 10px;
    }
    .pacman {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      z-index: 2;
      background-color: transparent;
      background-image: url('icon/wpface.png');
      background-size: cover;
    }
    .ghost {
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: transparent;
      background-size: cover;
      z-index: 1;
    }
    .pellet {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: transparent;
      background-image: url('icon/book.png');
      background-size: cover;
    }
    .power-pellet {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: transparent;
      background-image: url('icon/book.png');
      background-size: cover;
    }
    .wall {
      position: absolute;
      background-color: #00F;
    }
    #ghost-house {
      position: absolute;
      width: 80px;
      height: 40px;
      border: 2px solid #00F;
      background-color: transparent;
      top: 260px;
      left: 240px;
    }
    #ghost-door {
      position: absolute;
      width: 20px;
      height: 3px;
      background-color: #FFA500;
      top: 260px;
      left: 270px;
    }
    #game-over, #game-start {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 36px;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      display: none;
    }
    button {
      background-color: #FFFF00;
      border: none;
      padding: 10px 20px;
      font-size: 18px;
      margin-top: 20px;
      cursor: pointer;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="game-container">
    <div id="game-start">
      <h2>PAC-MAN</h2>
      <p>Use arrow keys to move</p>
      <button id="start-button">Start Game</button>
    </div>
    <div id="game-over">
      <h2>GAME OVER</h2>
      <p id="final-score">Your score: 0</p>
      <button id="restart-button">Play Again</button>
    </div>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Game variables
      const gameContainer = document.getElementById('game-container');
      const scoreDisplay = document.getElementById('score');
      const gameOverScreen = document.getElementById('game-over');
      const gameStartScreen = document.getElementById('game-start');
      const finalScoreDisplay = document.getElementById('final-score');
      const startButton = document.getElementById('start-button');
      const restartButton = document.getElementById('restart-button');
      
      let score = 0;
      let pacman;
      let ghosts = [];
      let pellets = [];
      let powerPellets = [];
      let walls = [];
      let gameRunning = false;
      let gameInterval;
      let ghostHouse;
      let gameStartTime;  // New variable to track game start time
      
      const containerWidth = 560;
      const containerHeight = 620;
      const cellSize = 20; // Size of one maze cell
      const wallThickness = 4; // Thinner walls (changed from 6 to 4)
      const pacmanSize = 18; // Pac-Man slightly smaller
      const pelletSize = 8;
      const powerPelletSize = 12;
      const ghostSize = 18; // Ghosts slightly smaller
      
      // Direction variables
      let direction = 'right';
      let nextDirection = 'right';
      const speed = 2;
      const ghostSpeed = 1.5;
      
      // Show start screen initially
      gameStartScreen.style.display = 'block';
      
      // Start and restart game
      startButton.addEventListener('click', startGame);
      restartButton.addEventListener('click', startGame);
      
      // Maze definition as a 2D array
      // 0: empty path, 1: wall, 2: pellet, 3: power pellet, 4: ghost house, 5: ghost door
      const mazeTemplate = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,3,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,3,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
        [1,2,1,0,0,1,2,1,1,2,1,0,0,0,0,0,0,1,2,1,1,2,1,0,0,1,2,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,2,1,1,0,0,0,0,1,1,0,0,0,0,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,1,2,1,1,0,1,1,0,1,1,0,1,1,0,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,1,0,4,4,4,4,0,1,0,1,1,2,1,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,0,1,0,4,4,4,4,0,1,0,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,0,2,0,0,0,1,0,4,4,4,4,0,1,0,0,0,2,0,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,1,2,1,1,0,1,1,1,1,5,1,1,1,0,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,1,0,0,1,2,1,0,0,0,1,2,1,1,2,1,0,0,0,1,2,1,0,0,1,2,1],
        [1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,3,1],
        [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
        [1,2,2,2,1,1,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,1,1,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,1,0,0,0,2,0,0,0,0,0,2,1,1,2,0,0,0,0,0,2,0,0,0,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
      ];
      
      function startGame() {
        // Reset game state
        gameContainer.innerHTML = '';
        gameContainer.appendChild(gameOverScreen);
        gameContainer.appendChild(gameStartScreen);
        gameOverScreen.style.display = 'none';
        gameStartScreen.style.display = 'none';
        score = 0;
        scoreDisplay.textContent = `Score: ${score}`;
        ghosts = [];
        pellets = [];
        powerPellets = [];
        walls = [];
        gameRunning = true;
        gameStartTime = Date.now();  // Record when the game starts
        createMaze();
        createGhostHouse();
        // Create Pac-Man
        pacman = document.createElement('div');
        pacman.className = 'pacman';
        pacman.style.left = `${14 * cellSize}px`;
        pacman.style.top = `${23 * cellSize}px`;
        gameContainer.appendChild(pacman);
        createGhosts();
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(updateGame, 30);
        document.addEventListener('keydown', handleKeyPress);
      }
      
      function createMaze() {
        for (let y = 0; y < mazeTemplate.length; y++) {
          for (let x = 0; x < mazeTemplate[y].length; x++) {
            const cell = mazeTemplate[y][x];
            const cellX = x * cellSize;
            const cellY = y * cellSize;
            if (cell === 1) {
              // Wall with thinner stroke
              const padding = (cellSize - wallThickness) / 2;
              createWall(cellX + padding, cellY + padding, wallThickness, wallThickness);
            } else if (cell === 2) {
              createPellet(cellX + (cellSize - pelletSize) / 2, cellY + (cellSize - pelletSize) / 2);
            } else if (cell === 3) {
              createPowerPellet(cellX + (cellSize - powerPelletSize) / 2, cellY + (cellSize - powerPelletSize) / 2);
            }
          }
        }
      }
      
      function createGhostHouse() {
        ghostHouse = {
          x: 240,
          y: 260,
          width: 80,
          height: 40,
          doorX: 270,
          doorY: 260,
          doorWidth: 20,
          doorHeight: 3
        };
        const houseElement = document.createElement('div');
        houseElement.id = 'ghost-house';
        gameContainer.appendChild(houseElement);
        const doorElement = document.createElement('div');
        doorElement.id = 'ghost-door';
        gameContainer.appendChild(doorElement);
      }
      
      function createWall(x, y, width, height) {
        const wall = document.createElement('div');
        wall.className = 'wall';
        wall.style.left = `${x}px`;
        wall.style.top = `${y}px`;
        wall.style.width = `${width}px`;
        wall.style.height = `${height}px`;
        gameContainer.appendChild(wall);
        walls.push({ x, y, width, height });
      }
      
      function createPellet(x, y) {
        const pellet = document.createElement('div');
        pellet.className = 'pellet';
        pellet.style.left = `${x}px`;
        pellet.style.top = `${y}px`;
        gameContainer.appendChild(pellet);
        pellets.push({ x, y, element: pellet, eaten: false });
      }
      
      function createPowerPellet(x, y) {
        const powerPellet = document.createElement('div');
        powerPellet.className = 'power-pellet';
        powerPellet.style.left = `${x}px`;
        powerPellet.style.top = `${y}px`;
        gameContainer.appendChild(powerPellet);
        powerPellets.push({ x, y, element: powerPellet, eaten: false });
      }
      
      function createGhosts() {
        const positions = [
          { x: 260, y: 280 },
          { x: 280, y: 280 },
          { x: 260, y: 260 },
          { x: 280, y: 260 }
        ];
        for (let i = 0; i < 4; i++) {
          const ghost = document.createElement('div');
          ghost.className = 'ghost';
          ghost.style.left = `${positions[i].x}px`;
          ghost.style.top = `${positions[i].y}px`;
          ghost.style.backgroundImage = `url('icon/ghost${i+1}.png')`;
          gameContainer.appendChild(ghost);
          ghosts.push({
            x: positions[i].x,
            y: positions[i].y,
            element: ghost,
            direction: getRandomDirection(),
            inHouse: true,
            releaseTime: i * 3000 // Release timing in milliseconds
          });
        }
      }
      
      function getRandomDirection() {
        const directions = ['up', 'down', 'left', 'right'];
        return directions[Math.floor(Math.random() * directions.length)];
      }
      
      function updateGame() {
        if (!gameRunning) return;
        movePacman();
        checkPelletCollisions();
        updateGhosts();
        moveGhosts();
        checkGhostCollisions();
        if (pellets.every(p => p.eaten) && powerPellets.every(p => p.eaten)) {
          gameOver(true);
        }
      }
      
      function updateGhosts() {
        const currentTime = Date.now();
        ghosts.forEach(ghost => {
          if (ghost.inHouse && (currentTime - gameStartTime > ghost.releaseTime)) {
            ghost.inHouse = false;
            ghost.x = ghostHouse.doorX;
            ghost.y = ghostHouse.doorY - ghostSize;
            ghost.element.style.left = `${ghost.x}px`;
            ghost.element.style.top = `${ghost.y}px`;
            ghost.direction = 'up';
          }
        });
      }
      
      function movePacman() {
        let newX = parseInt(pacman.style.left);
        let newY = parseInt(pacman.style.top);
        if (nextDirection !== direction) {
          let testX = newX;
          let testY = newY;
          switch (nextDirection) {
            case 'up': testY -= speed; break;
            case 'down': testY += speed; break;
            case 'left': testX -= speed; break;
            case 'right': testX += speed; break;
          }
          if (!isCollidingWithWalls(testX, testY, pacmanSize, pacmanSize)) {
            direction = nextDirection;
          }
        }
        switch (direction) {
          case 'up': newY -= speed; break;
          case 'down': newY += speed; break;
          case 'left': newX -= speed; break;
          case 'right': newX += speed; break;
        }
        if (!isCollidingWithWalls(newX, newY, pacmanSize, pacmanSize)) {
          if (newX < -pacmanSize && direction === 'left') {
            newX = containerWidth;
          } else if (newX > containerWidth && direction === 'right') {
            newX = -pacmanSize;
          }
          pacman.style.left = `${newX}px`;
          pacman.style.top = `${newY}px`;
        }
      }
      
      function isCollidingWithWalls(x, y, width, height) {
        for (const wall of walls) {
          if (x < wall.x + wall.width &&
              x + width > wall.x &&
              y < wall.y + wall.height &&
              y + height > wall.y) {
            return true;
          }
        }
        if (width === pacmanSize) {
          const gh = { x: ghostHouse.x, y: ghostHouse.y, width: ghostHouse.width, height: ghostHouse.height };
          if (
            x < gh.x + gh.width &&
            x + width > gh.x &&
            y < gh.y + gh.height &&
            y + height > gh.y &&
            !(x + width/2 >= ghostHouse.doorX && x + width/2 <= ghostHouse.doorX + ghostHouse.doorWidth &&
              y <= ghostHouse.doorY && y + height >= ghostHouse.doorY)
          ) {
            return true;
          }
        }
        return false;
      }
      
      function checkPelletCollisions() {
        const pacmanX = parseInt(pacman.style.left) + pacmanSize/2;
        const pacmanY = parseInt(pacman.style.top) + pacmanSize/2;
        pellets.forEach(pellet => {
          if (!pellet.eaten) {
            const pelletX = pellet.x + pelletSize/2;
            const pelletY = pellet.y + pelletSize/2;
            const distance = Math.sqrt(Math.pow(pacmanX - pelletX, 2) + Math.pow(pacmanY - pelletY, 2));
            if (distance < (pacmanSize/2) + (pelletSize/2)) {
              pellet.eaten = true;
              pellet.element.style.display = 'none';
              score += 10;
              scoreDisplay.textContent = `Score: ${score}`;
            }
          }
        });
        powerPellets.forEach(pellet => {
          if (!pellet.eaten) {
            const pelletX = pellet.x + powerPelletSize/2;
            const pelletY = pellet.y + powerPelletSize/2;
            const distance = Math.sqrt(Math.pow(pacmanX - pelletX, 2) + Math.pow(pacmanY - pelletY, 2));
            if (distance < (pacmanSize/2) + (powerPelletSize/2)) {
              pellet.eaten = true;
              pellet.element.style.display = 'none';
              score += 50;
              scoreDisplay.textContent = `Score: ${score}`;
              // Add ghost vulnerability logic here if desired
            }
          }
        });
      }
      
      function moveGhosts() {
        ghosts.forEach(ghost => {
          if (ghost.inHouse) {
            ghost.y += (Math.random() > 0.5 ? 0.5 : -0.5);
            ghost.element.style.top = `${ghost.y}px`;
            return;
          }
          let newX = ghost.x;
          let newY = ghost.y;
          if (Math.random() < 0.03 || isAtIntersection(ghost.x, ghost.y)) {
            ghost.direction = getSmartDirection(ghost, parseInt(pacman.style.left), parseInt(pacman.style.top));
          }
          switch (ghost.direction) {
            case 'up': newY -= ghostSpeed; break;
            case 'down': newY += ghostSpeed; break;
            case 'left': newX -= ghostSpeed; break;
            case 'right': newX += ghostSpeed; break;
          }
          if (!isCollidingWithWalls(newX, newY, ghostSize, ghostSize)) {
            if (newX < -ghostSize && ghost.direction === 'left') {
              newX = containerWidth;
            } else if (newX > containerWidth && ghost.direction === 'right') {
              newX = -ghostSize;
            }
            ghost.x = newX;
            ghost.y = newY;
            ghost.element.style.left = `${newX}px`;
            ghost.element.style.top = `${newY}px`;
          } else {
            ghost.direction = getAlternateDirection(ghost.direction);
          }
        });
      }
      
      function isAtIntersection(x, y) {
        const directions = ['up', 'down', 'left', 'right'];
        let available = 0;
        directions.forEach(dir => {
          let testX = x, testY = y;
          switch (dir) {
            case 'up': testY -= cellSize/2; break;
            case 'down': testY += cellSize/2; break;
            case 'left': testX -= cellSize/2; break;
            case 'right': testX += cellSize/2; break;
          }
          if (!isCollidingWithWalls(testX, testY, ghostSize, ghostSize)) available++;
        });
        return available > 2;
      }
      
      function getSmartDirection(ghost, pacX, pacY) {
        if (Math.random() < 0.8) {
          const dx = pacX - ghost.x;
          const dy = pacY - ghost.y;
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && canMove(ghost.x, ghost.y, 'right')) return 'right';
            if (dx < 0 && canMove(ghost.x, ghost.y, 'left')) return 'left';
            if (dy > 0 && canMove(ghost.x, ghost.y, 'down')) return 'down';
            if (canMove(ghost.x, ghost.y, 'up')) return 'up';
          } else {
            if (dy > 0 && canMove(ghost.x, ghost.y, 'down')) return 'down';
            if (dy < 0 && canMove(ghost.x, ghost.y, 'up')) return 'up';
            if (dx > 0 && canMove(ghost.x, ghost.y, 'right')) return 'right';
            if (canMove(ghost.x, ghost.y, 'left')) return 'left';
          }
        }
        return getRandomValidDirection(ghost.x, ghost.y, ghost.direction);
      }
      
      function canMove(x, y, dir) {
        let testX = x, testY = y;
        switch (dir) {
          case 'up': testY -= ghostSpeed; break;
          case 'down': testY += ghostSpeed; break;
          case 'left': testX -= ghostSpeed; break;
          case 'right': testX += ghostSpeed; break;
        }
        return !isCollidingWithWalls(testX, testY, ghostSize, ghostSize);
      }
      
      function getRandomValidDirection(x, y, currentDir) {
        const directions = ['up', 'down', 'left', 'right'];
        const valid = directions.filter(dir => canMove(x, y, dir) && dir !== currentDir);
        if (valid.length === 0) return currentDir;
        return valid[Math.floor(Math.random() * valid.length)];
      }
      
      function getAlternateDirection(currentDir) {
        return (currentDir === 'up' || currentDir === 'down') ? 'left' : 'up';
      }
      
      function checkGhostCollisions() {
        const pacX = parseInt(pacman.style.left) + pacmanSize/2;
        const pacY = parseInt(pacman.style.top) + pacmanSize/2;
        ghosts.forEach(ghost => {
          const ghostX = ghost.x + ghostSize/2;
          const ghostY = ghost.y + ghostSize/2;
          const distance = Math.sqrt(Math.pow(pacX - ghostX, 2) + Math.pow(pacY - ghostY, 2));
          if (distance < (pacmanSize/2 + ghostSize/2)) {
            gameOver(false);
          }
        });
      }
      
      // New function to handle key presses for Pac-Man movement
      function handleKeyPress(e) {
        switch(e.key) {
          case 'ArrowUp': nextDirection = 'up'; break;
          case 'ArrowDown': nextDirection = 'down'; break;
          case 'ArrowLeft': nextDirection = 'left'; break;
          case 'ArrowRight': nextDirection = 'right'; break;
        }
      }
      
      function gameOver(won) {
        gameRunning = false;
        clearInterval(gameInterval);
        gameOverScreen.style.display = 'block';
        finalScoreDisplay.textContent = `Your score: ${score}`;
      }
    });
  </script>
</body>
</html>
